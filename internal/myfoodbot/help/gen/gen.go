package main

import (
	"bytes"
	"compress/gzip"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"html/template"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	funcs = template.FuncMap{"pack": packBytes}
	tmpl  = template.Must(template.New("").Funcs(funcs).Parse(`package help

// code generated by go generate. DO NOT EDIT.

func init() {
    {{- range $name, $file := . }}
        add("{{ $name }}", []byte{ {{ pack $file }} })
    {{- end }}
}
`))
)

func main() {
	inPath := flag.String("in", "", "")
	fileName := flag.String("out", "", "")
	flag.Parse()

	helpDocs := make(map[string][]byte, 0)

	err := filepath.Walk(*inPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if filepath.Ext(path) != ".html" {
			return nil
		}

		fileData, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		name := strings.TrimSuffix(filepath.Base(path), filepath.Ext(path))
		helpDocs[name] = fileData

		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	buf := &bytes.Buffer{}

	if err = tmpl.Execute(buf, helpDocs); err != nil {
		log.Fatal(err)
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err = os.WriteFile(*fileName, data, os.ModePerm); err != nil {
		log.Fatal(err)
	}
}

func packBytes(s []byte) string {
	var b bytes.Buffer

	gz := gzip.NewWriter(&b)
	if _, err := gz.Write(s); err != nil {
		log.Fatal(err)
	}
	if err := gz.Close(); err != nil {
		log.Fatal(err)
	}

	builder := strings.Builder{}
	for {
		v, err := b.ReadByte()
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			log.Fatal(err)
		}

		builder.WriteString(fmt.Sprintf("%d,", int(v)))
	}
	return builder.String()
}
